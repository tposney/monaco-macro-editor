
    export default [
      "@league-of-foundry-developers\\foundry-vtt-types\\src\\types\\utils.d.ts",
      "/**\n * Recursively sets keys of an object to optional. Used primarily for update methods\n * @internal\n */declare type DeepPartial<T>={[P in keyof T]?:T[P]extends object?DeepPartial<T[P]>:T[P];};/**\n * References the constructor of type `T`\n * @internal\n */type ConstructorOf<T>=new(...args:any)=>T;/**\n * Omit properties of `T` which are of type `U`.\n *\n * @typeParam T - Object type from which properties will be omitted.\n * @typeParam U - Properties of this type will be omitted.\n * @internal\n */type OmitOfType<T extends object,U>={[k in keyof T as T[k]extends U?never:k]:T[k]};/**\n * If T extends `U`, the resulting type is `R`, otherwise it is `T`.\n *\n * @typeParam T - Original type.\n * @typeParam U - Only convert types of this type.\n * @typeParam R - Adjust to this type.\n * @internal\n */type TypeToType<T,U,R>=T extends U?R:T;/**\n * Map the types of properties of `T` to `R` if they are of type `U`.\n *\n * @typeParam T - Object type that will have its properties' types adjusted.\n * @typeParam U - Adjust the types of properties of this type.\n * @typeParam R - Type that properties' types will be adjusted to.\n * @internal\n */type MapTypeToType<T,U,R>={[k in keyof T]:TypeToType<T[k],U,R>};/**\n * Omit properties of `T` which are assignable from `U`.\n *\n * @typeParam T - Object type that will have its properties omitted.\n * @typeParam U - Properties with types that are assignable from this type will be omitted.\n * @internal\n */type OmitAssignableFromType<T extends object,U>={[k in keyof T as U extends T[k]?never:k]:T[k]};/**\n * Omit properties of `T` which are not assignable from `U`.\n *\n * @typeParam T - Object type that will have its properties omitted.\n * @typeParam U - Properties with types that are not assignable from this type will be omitted.\n * @internal\n */type OmitNotAssignableFromType<T extends object,U>={[k in keyof T as U extends T[k]?k:never]:T[k]};/**\n * Expand an object that contains keys in dotted notation\n * @internal\n */type Expanded<O>=O extends Record<string,unknown>?{[KO in keyof O as KO extends`${infer A}.${string}` ? A : KO]: KO extends `${string}.${infer B}`\n        ? Expanded<{ [EB in B]: O[KO] }>\n        : Expanded<O[KO]>;\n    }\n  : O;\n\n/**\n * Union type of the types of the values in `T`\n * @internal\n */\ntype ValueOf<T> = T extends Array<unknown> ? T[number] : T[keyof T];\n\n/**\n * Transforms a string to lowercase and the first character to uppercase.\n * @internal\n */\ntype Titlecase<S extends string> = S extends `${infer A}${infer B}`\n  ? `${Titlecase<A>}${Titlecase<B>}`\n  : Capitalize<Lowercase<S>>;\n\n/**\n * Deeply merge two types. If either of the given types is not an `object`, `U`\n * simply overwrites `T`.\n *\n * Nested properties of type `object` are merged recursively unless the property\n * in `U` is an `Array`.\n *\n * @typeParam T - The base type that `U` will be merged into.\n * @typeParam U - The type that will be merged into `T`.\n */\ntype Merge<T, U> = T extends object\n  ? U extends Array<any>\n    ? U\n    : U extends object\n    ? {\n        [Key in keyof T | keyof U]: Key extends keyof T\n          ? Key extends keyof U\n            ? Merge<T[Key], U[Key]>\n            : T[Key]\n          : Key extends keyof U\n          ? U[Key]\n          : never;\n      }\n    : U\n  : U;\n\n/**\n * If `T` is `Promise<TResult>` then `TResult`; otherwise `T`.\n * @typeParam T - the type which, if a Promise, will be unwrapped.\n */\ntype PromisedType<T> = T extends Promise<infer TResult> ? TResult : T;\n\ntype StoredDocument<D extends foundry.abstract.Document<any, any>> = D & {\n  id: string;\n  data: D['data'] & {\n    _id: string;\n    _source: D['data']['_source'] & { _id: string };\n  };\n};\n\ntype TemporaryDocument<D> = D extends StoredDocument<infer U> ? U : D;\n\ntype PropertyTypeOrFallback<T, Key extends string, Fallback> = Key extends keyof T ? T[Key] : Fallback;\n"
    ]
  