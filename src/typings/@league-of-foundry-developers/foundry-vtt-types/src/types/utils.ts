
    export default [
      "@league-of-foundry-developers\\foundry-vtt-types\\src\\types\\utils.d.ts",
      "/**\n * Recursively sets keys of an object to optional. Used primarily for update methods\n * @internal\n */\ndeclare type DeepPartial<T> = {\n  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];\n};\n\n/**\n * References the constructor of type `T`\n * @internal\n */\ntype ConstructorOf<T> = new (...args: any) => T;\n\n/**\n * Omit properties of `T` which are of type `U`.\n *\n * @typeParam T - Object type from which properties will be omitted.\n * @typeParam U - Properties of this type will be omitted.\n * @internal\n */\ntype OmitOfType<T extends object, U> = { [k in keyof T as T[k] extends U ? never : k]: T[k] };\n\n/**\n * If T extends `U`, the resulting type is `R`, otherwise it is `T`.\n *\n * @typeParam T - Original type.\n * @typeParam U - Only convert types of this type.\n * @typeParam R - Adjust to this type.\n * @internal\n */\ntype TypeToType<T, U, R> = T extends U ? R : T;\n\n/**\n * Map the types of properties of `T` to `R` if they are of type `U`.\n *\n * @typeParam T - Object type that will have its properties' types adjusted.\n * @typeParam U - Adjust the types of properties of this type.\n * @typeParam R - Type that properties' types will be adjusted to.\n * @internal\n */\ntype MapTypeToType<T, U, R> = { [k in keyof T]: TypeToType<T[k], U, R> };\n\n/**\n * Omit properties of `T` which are assignable from `U`.\n *\n * @typeParam T - Object type that will have its properties omitted.\n * @typeParam U - Properties with types that are assignable from this type will be omitted.\n * @internal\n */\ntype OmitAssignableFromType<T extends object, U> = { [k in keyof T as U extends T[k] ? never : k]: T[k] };\n\n/**\n * Omit properties of `T` which are not assignable from `U`.\n *\n * @typeParam T - Object type that will have its properties omitted.\n * @typeParam U - Properties with types that are not assignable from this type will be omitted.\n * @internal\n */\ntype OmitNotAssignableFromType<T extends object, U> = { [k in keyof T as U extends T[k] ? k : never]: T[k] };\n\n/**\n * Expand an object that contains keys in dotted notation\n * @internal\n */\ntype Expanded<O> = O extends Record<string, unknown>\n  ? {\n      [KO in keyof O as KO extends `${infer A}.${string}` ? A : KO]: KO extends `${string}.${infer B}`\n        ? Expanded<{ [EB in B]: O[KO] }>\n        : Expanded<O[KO]>;\n    }\n  : O;\n\n/**\n * Union type of the types of the values in `T`\n * @internal\n */\ntype ValueOf<T> = T extends Array<unknown> ? T[number] : T[keyof T];\n\n/**\n * Transforms a string to lowercase and the first character to uppercase.\n * @internal\n */\ntype Titlecase<S extends string> = S extends `${infer A} ${infer B}`\n  ? `${Titlecase<A>} ${Titlecase<B>}`\n  : Capitalize<Lowercase<S>>;\n\n/**\n * Deeply merge two types. If either of the given types is not an `object`, `U`\n * simply overwrites `T`.\n *\n * Nested properties of type `object` are merged recursively unless the property\n * in `U` is an `Array`.\n *\n * @typeParam T - The base type that `U` will be merged into.\n * @typeParam U - The type that will be merged into `T`.\n */\ntype Merge<T, U> = T extends object\n  ? U extends Array<any>\n    ? U\n    : U extends object\n    ? {\n        [Key in keyof T | keyof U]: Key extends keyof T\n          ? Key extends keyof U\n            ? Merge<T[Key], U[Key]>\n            : T[Key]\n          : Key extends keyof U\n          ? U[Key]\n          : never;\n      }\n    : U\n  : U;\n"
    ]
  